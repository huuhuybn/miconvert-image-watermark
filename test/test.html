<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@miconvert/image-watermark ‚Äî Automated Tests</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #111;
            color: #eee;
            padding: 2rem;
        }

        h1 {
            text-align: center;
            margin-bottom: 1rem;
            color: #a29bfe;
        }

        #status {
            text-align: center;
            margin-bottom: 2rem;
            font-size: 1.1rem;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
        }

        .test-card {
            background: #1a1a2e;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid #333;
        }

        .test-card.pass {
            border-color: #00cec9;
        }

        .test-card.fail {
            border-color: #ff6b6b;
        }

        .test-card .card-header {
            padding: 0.8rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.03);
        }

        .test-card .card-header .name {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .test-card .card-header .badge {
            padding: 0.2rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 700;
        }

        .badge.pass {
            background: rgba(0, 206, 201, 0.2);
            color: #00cec9;
        }

        .badge.fail {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }

        .badge.running {
            background: rgba(162, 155, 254, 0.2);
            color: #a29bfe;
        }

        .test-card img {
            width: 100%;
            display: block;
        }

        .test-card .info {
            padding: 0.6rem 1rem;
            font-size: 0.8rem;
            color: #888;
        }

        .summary {
            text-align: center;
            margin-top: 2rem;
            padding: 1.5rem;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .summary.all-pass {
            background: rgba(0, 206, 201, 0.15);
            color: #00cec9;
        }

        .summary.has-fail {
            background: rgba(255, 107, 107, 0.15);
            color: #ff6b6b;
        }
    </style>
</head>

<body>
    <h1>üß™ @miconvert/image-watermark ‚Äî Test Suite</h1>
    <div id="status">Initializing tests...</div>
    <div class="test-grid" id="testGrid"></div>
    <div id="summary"></div>

    <script type="module">
        import { addWatermark } from '../dist/image-watermark.mjs';

        const grid = document.getElementById('testGrid');
        const statusEl = document.getElementById('status');
        const summaryEl = document.getElementById('summary');

        let passed = 0;
        let failed = 0;
        let total = 0;

        // --- Create a test source image (gradient) using canvas ---
        function createTestImage(w = 800, h = 600) {
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            // Background gradient
            const grad = ctx.createLinearGradient(0, 0, w, h);
            grad.addColorStop(0, '#1a1a2e');
            grad.addColorStop(0.5, '#16213e');
            grad.addColorStop(1, '#0f3460');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Grid pattern
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            for (let x = 0; x < w; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
            for (let y = 0; y < h; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }

            // Center circle
            ctx.beginPath();
            ctx.arc(w / 2, h / 2, 80, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(108,92,231,0.3)';
            ctx.fill();

            // Text
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.textAlign = 'center';
            ctx.fillText(`Test Image ${w}√ó${h}`, w / 2, h / 2 + 5);

            return new Promise((resolve) => {
                canvas.toBlob((blob) => resolve(blob), 'image/png');
            });
        }

        // --- Create a test logo (simple colored rectangle with text) ---
        function createTestLogo() {
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 80;
            const ctx = canvas.getContext('2d');

            // Rounded rect background
            ctx.fillStyle = '#6c5ce7';
            ctx.beginPath();
            ctx.roundRect(0, 0, 200, 80, 12);
            ctx.fill();

            // Logo text
            ctx.font = 'bold 28px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('MICONVERT', 100, 42);

            return new Promise((resolve) => {
                canvas.toBlob((blob) => resolve(blob), 'image/png');
            });
        }

        // --- Test runner ---
        function createCard(name) {
            total++;
            const card = document.createElement('div');
            card.className = 'test-card';
            card.id = `test-${total}`;
            card.innerHTML = `
                <div class="card-header">
                    <span class="name">${name}</span>
                    <span class="badge running" id="badge-${total}">‚è≥ Running</span>
                </div>
                <div id="imgWrap-${total}"></div>
                <div class="info" id="info-${total}">Processing...</div>
            `;
            grid.appendChild(card);
            return total;
        }

        function markPass(id, info) {
            passed++;
            const card = document.getElementById(`test-${id}`);
            card.classList.add('pass');
            document.getElementById(`badge-${id}`).className = 'badge pass';
            document.getElementById(`badge-${id}`).textContent = '‚úÖ PASS';
            document.getElementById(`info-${id}`).textContent = info;
        }

        function markFail(id, error) {
            failed++;
            const card = document.getElementById(`test-${id}`);
            card.classList.add('fail');
            document.getElementById(`badge-${id}`).className = 'badge fail';
            document.getElementById(`badge-${id}`).textContent = '‚ùå FAIL';
            document.getElementById(`info-${id}`).textContent = `Error: ${error}`;
        }

        function showImage(id, blob) {
            const url = URL.createObjectURL(blob);
            const img = document.createElement('img');
            img.src = url;
            document.getElementById(`imgWrap-${id}`).appendChild(img);
        }

        async function runTest(name, testFn) {
            const id = createCard(name);
            statusEl.textContent = `Running: ${name}...`;
            try {
                const { blob, info } = await testFn();
                if (blob && blob.size > 0) {
                    showImage(id, blob);
                    markPass(id, info || `Output: ${(blob.size / 1024).toFixed(1)} KB`);
                } else {
                    markFail(id, 'Output blob is empty or null');
                }
            } catch (err) {
                markFail(id, err.message);
                console.error(`Test "${name}" failed:`, err);
            }
        }

        // ===== TEST SUITE =====
        async function runAllTests() {
            const testImage = await createTestImage(800, 600);
            const testImage4K = await createTestImage(3840, 2160);
            const testLogo = await createTestLogo();

            // --- 1. Basic Text Watermark ---
            await runTest('1. Text Watermark ‚Äî Bottom Right', async () => {
                const blob = await addWatermark(testImage, {
                    type: 'text',
                    text: '¬© Miconvert 2026',
                    position: 'bottom-right',
                    fontSize: 36,
                    color: 'rgba(255,255,255,0.7)',
                    padding: 20,
                });
                return { blob, info: `Size: ${(blob.size / 1024).toFixed(1)} KB ‚Äî basic text at bottom-right` };
            });

            // --- 2. Text with Stroke + Shadow ---
            await runTest('2. Text ‚Äî Stroke + Shadow', async () => {
                const blob = await addWatermark(testImage, {
                    type: 'text',
                    text: '¬© Miconvert Property',
                    position: 'bottom-right',
                    fontSize: 40,
                    color: '#ffffff',
                    strokeColor: '#000000',
                    strokeWidth: 3,
                    shadowColor: 'rgba(0,0,0,0.8)',
                    shadowBlur: 6,
                    opacity: 0.8,
                    padding: 25,
                });
                return { blob, info: `Size: ${(blob.size / 1024).toFixed(1)} KB ‚Äî stroke + shadow` };
            });

            // --- 3. Text at Center with Rotation ---
            await runTest('3. Text ‚Äî Center + Rotation -30¬∞', async () => {
                const blob = await addWatermark(testImage, {
                    type: 'text',
                    text: 'SAMPLE ONLY',
                    position: 'center',
                    fontSize: 60,
                    color: 'rgba(255,100,100,0.6)',
                    rotate: -30,
                    fontWeight: 'bold',
                });
                return { blob, info: `Size: ${(blob.size / 1024).toFixed(1)} KB ‚Äî rotated center text` };
            });

            // --- 4. All 9 Positions ---
            const positions = [
                'top-left', 'top-center', 'top-right',
                'center-left', 'center', 'center-right',
                'bottom-left', 'bottom-center', 'bottom-right'
            ];
            await runTest('4. All 9 Positions (sequential)', async () => {
                let blob = testImage;
                for (const pos of positions) {
                    blob = await addWatermark(blob, {
                        type: 'text',
                        text: pos,
                        position: pos,
                        fontSize: 18,
                        color: 'rgba(0,255,200,0.9)',
                        strokeColor: '#000',
                        strokeWidth: 1,
                        padding: 10,
                    });
                }
                return { blob, info: `All 9 positions rendered on one image` };
            });

            // --- 5. Text Tiled Pattern ---
            await runTest('5. Tiled Text ‚Äî Anti-Crop', async () => {
                const blob = await addWatermark(testImage, {
                    type: 'text',
                    text: 'B·∫£n quy·ªÅn Miconvert',
                    mode: 'tiled',
                    opacity: 0.25,
                    rotate: -45,
                    fontSize: 28,
                    color: 'rgba(255,255,255,0.5)',
                    strokeColor: 'rgba(0,0,0,0.3)',
                    strokeWidth: 1,
                });
                return { blob, info: `Size: ${(blob.size / 1024).toFixed(1)} KB ‚Äî tiled diagonal text` };
            });

            // --- 6. Image/Logo Watermark ---
            await runTest('6. Logo Watermark ‚Äî 15%', async () => {
                const blob = await addWatermark(testImage, {
                    type: 'image',
                    imageElement: testLogo,
                    position: 'bottom-right',
                    width: 0.15,
                    opacity: 0.8,
                    padding: 20,
                });
                return { blob, info: `Size: ${(blob.size / 1024).toFixed(1)} KB ‚Äî logo at 15% width` };
            });

            // --- 7. Logo at Top-Left with Rotation ---
            await runTest('7. Logo ‚Äî Top-Left + Rotation', async () => {
                const blob = await addWatermark(testImage, {
                    type: 'image',
                    imageElement: testLogo,
                    position: 'top-left',
                    width: 0.2,
                    opacity: 0.6,
                    rotate: -15,
                    padding: 30,
                });
                return { blob, info: `Size: ${(blob.size / 1024).toFixed(1)} KB ‚Äî logo top-left rotated` };
            });

            // --- 8. Tiled Logo ---
            await runTest('8. Tiled Logo ‚Äî Pattern', async () => {
                const blob = await addWatermark(testImage, {
                    type: 'image',
                    imageElement: testLogo,
                    mode: 'tiled',
                    width: 0.1,
                    opacity: 0.15,
                    rotate: -30,
                    tileSpacingX: 60,
                    tileSpacingY: 50,
                });
                return { blob, info: `Size: ${(blob.size / 1024).toFixed(1)} KB ‚Äî tiled logo pattern` };
            });

            // --- 9. Responsive Scaling on 4K Image ---
            await runTest('9. Responsive Scale ‚Äî 4K Image', async () => {
                const blob = await addWatermark(testImage4K, {
                    type: 'text',
                    text: '¬© 4K Watermark Test',
                    position: 'bottom-right',
                    fontSize: 36,
                    scale: 1.0,
                    color: 'rgba(255,255,0,0.8)',
                    strokeColor: '#000',
                    strokeWidth: 2,
                    padding: 40,
                });
                return { blob, info: `Size: ${(blob.size / 1024).toFixed(1)} KB ‚Äî text auto-scaled on 3840√ó2160` };
            });

            // --- 10. Low Opacity ---
            await runTest('10. Opacity 0.1 (Very Subtle)', async () => {
                const blob = await addWatermark(testImage, {
                    type: 'text',
                    text: 'VERY SUBTLE WATERMARK',
                    position: 'center',
                    fontSize: 60,
                    color: '#ffffff',
                    opacity: 0.1,
                });
                return { blob, info: `Size: ${(blob.size / 1024).toFixed(1)} KB ‚Äî opacity 0.1` };
            });

            // --- 11. Error Handling: No text ---
            await runTest('11. Error: Missing text field', async () => {
                try {
                    await addWatermark(testImage, { type: 'text', text: '' });
                    return { blob: null };
                } catch (err) {
                    // Expected error ‚Äî this IS the pass condition
                    const canvas = document.createElement('canvas');
                    canvas.width = 400; canvas.height = 100;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(0, 0, 400, 100);
                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#00cec9';
                    ctx.fillText('‚úÖ Correctly threw:', 20, 35);
                    ctx.fillStyle = '#eee';
                    ctx.fillText(err.message, 20, 65);
                    return new Promise(resolve => {
                        canvas.toBlob(b => resolve({ blob: b, info: 'Error caught correctly' }));
                    });
                }
            });

            // --- 12. Error Handling: No image source ---
            await runTest('12. Error: Missing image source', async () => {
                try {
                    await addWatermark(testImage, { type: 'image' });
                    return { blob: null };
                } catch (err) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 400; canvas.height = 100;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(0, 0, 400, 100);
                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#00cec9';
                    ctx.fillText('‚úÖ Correctly threw:', 20, 35);
                    ctx.fillStyle = '#eee';
                    ctx.fillText(err.message, 20, 65);
                    return new Promise(resolve => {
                        canvas.toBlob(b => resolve({ blob: b, info: 'Error caught correctly' }));
                    });
                }
            });

            // --- Summary ---
            statusEl.textContent = `All tests completed: ${passed}/${total} passed`;
            summaryEl.className = `summary ${failed === 0 ? 'all-pass' : 'has-fail'}`;
            summaryEl.textContent = failed === 0
                ? `üéâ ALL ${total} TESTS PASSED`
                : `‚ö†Ô∏è ${passed}/${total} passed, ${failed} failed`;
        }

        runAllTests();
    </script>
</body>

</html>